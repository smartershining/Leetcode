package com.smartershining;/** * Created by smartershining on 16-5-13. *//** * Given a string S, find the longest palindromic substring in S. * You may assume that the maximum length of S is 1000, and there exists one unique longest palindromic substring. */public class LongestPalindrome {    public String longestPalindrome(String s) {        if (s == null || s.length() <= 1) {            return s;        }        int length = 0;        int begin = 0;        int end = 0;        for (int i = 0; i < s.length(); i++) {            int j = i - 1;            int k = i + 1;            int total = 1;            while (j >= 0 && k < s.length() && s.charAt(j) == s.charAt(k)) {                j--;                k++;                total += 2;            }            if (total > length) {                begin = j;                end = k;                length = total;            }            j = i;            k = i + 1;            total = 0;            while (j >= 0 && k < s.length() && s.charAt(j) == s.charAt(k)) {                j--;                k++;                total += 2;            }            if (total > length) {                begin = i;                end = k;                length = total;            }        }        return s.substring(begin + 1, end);    }    public String longestPalindrome2(String s) {        if (s == null || s.length() == 0) {            return null;        }        if (s.length() == 1) {            return s;        }        int len = s.length();        int maxlen = 0;        String longest = null;        boolean[][] dp = new boolean[len][len];        for (int i = len - 1; i >= 0; i--) {            for (int j = i; j < len; j++) {                if (s.charAt(i) == s.charAt(j) && (j - i <= 2 || dp[i + 1][j - 1])) {                    dp[i][j] = true;                    if (j - i + 1 > maxlen) {                        longest = s.substring(i, j + 1);                        maxlen = j - i + 1;                    }                }            }        }        return longest;    }}